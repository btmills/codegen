// Generated by CoffeeScript 1.6.2
(function() {
  (function(root, factory) {
    if (typeof exports === 'object') {
      return module.exports = factory();
    } else if (typeof define === 'function' && define.amd) {
      return define(factory);
    } else {
      return root.Codegen = factory();
    }
  })(this, function() {
    'use strict';
    var extend, generate;

    extend = function() {
      var clone, copy, copyIsArray, deep, i, length, name, options, src, target, _i;

      target = arguments[0] || {};
      i = 1;
      length = arguments.length;
      deep = false;
      if (typeof target === 'boolean') {
        deep = target;
        target = arguments[1] || {};
        i = 2;
      }
      if (typeof target !== 'object' && typeof target !== 'function') {
        target = {};
      }
      for (i = _i = i; _i < length; i = _i += 1) {
        if ((options = arguments[i]) !== null) {
          for (name in options) {
            src = target[name];
            copy = options[name];
            if (target === copy) {
              continue;
            }
            if (deep && copy && (typeof copy === 'object' || (copyIsArray = typeof copy === 'array'))) {
              if (copyIsArray) {
                copyIsArray = false;
                clone = src && (typeof src === 'array' ? src : []);
              } else {
                clone = src && (typeof src === 'object' ? src : {});
              }
              target[name] = extend(deep, clone, copy);
            } else if (copy !== void 0) {
              target((name = copy[0], copy));
            }
          }
        }
      }
      return target;
    };
    generate = function(tree, options) {
      var between, codegen, cssify, generators, indent, indentation, region, str, syntax, terminals;

      options = extend(true, {
        format: {
          indent: {
            style: '    ',
            base: 0
          },
          html: false,
          semicolons: true
        }
      }, options);
      str = [];
      indentation = options.format.indent.base;
      between = function(els, fn, bw) {
        var el, run, _i, _len, _results;

        run = false;
        _results = [];
        for (_i = 0, _len = els.length; _i < _len; _i++) {
          el = els[_i];
          if (run) {
            if (typeof bw === 'function') {
              bw();
            } else if (typeof bw === 'string') {
              str.push(bw);
            }
          }
          fn(el);
          _results.push(run = true);
        }
        return _results;
      };
      /*
      		Indent a new line to the correct level
      		delta increases or decreases indentation level
      		temp does not update indent level
      */

      indent = function(delta, temp) {
        var i, _i, _ref;

        terminals.newline();
        if (options.format.html) {
          for (i = _i = 0, _ref = indentation + (+delta || 0); 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            str.push('<span class="indent"></span>');
          }
        } else {
          str.push(((function() {
            var _j, _ref1, _results;

            _results = [];
            for (i = _j = 0, _ref1 = indentation + (+delta || 0); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
              _results.push(options.format.indent.style);
            }
            return _results;
          })()).join(''));
        }
        if (!temp) {
          return indentation += +delta || 0;
        }
      };
      region = function(type, content) {
        if (options.format.html) {
          str.push("<span class=\"region " + type + "\">");
        }
        content();
        if (options.format.html) {
          return str.push('</span>');
        }
      };
      syntax = {
        ArrayExpression: ['elements'],
        AssignmentExpression: ['left', 'operator', 'right'],
        BinaryExpression: ['left', 'operator', 'right'],
        BlockStatement: ['body'],
        BreakStatement: ['label'],
        CallExpression: ['callee', 'arguments'],
        CatchClause: ['param', 'guard', 'body'],
        ConditionalExpression: ['test', 'consequent', 'alternate'],
        ContinueStatement: ['label'],
        DebuggerStatement: [],
        DoWhileStatement: ['body', 'test'],
        EmptyStatement: [],
        ExpressionStatement: ['expression'],
        ForInStatement: ['left', 'right', 'body', 'each'],
        ForOfStatement: ['left', 'right', 'body'],
        ForStatement: ['init', 'test', 'update', 'body'],
        FunctionDeclaration: ['id', 'params', 'defaults', 'rest', 'body'],
        FunctionExpression: ['id', 'params', 'defaults', 'rest', 'body'],
        Identifier: ['name'],
        IfStatement: ['test', 'consequent', 'alternate'],
        LabeledStatement: ['label', 'body'],
        Literal: ['raw'],
        LogicalExpression: ['left', 'operator', 'right'],
        MemberExpression: ['object', 'property', 'computed'],
        NewExpression: ['callee', 'arguments'],
        ObjectExpression: ['properties'],
        Pattern: [],
        Program: ['body'],
        Property: ['key', 'value'],
        ReturnStatement: ['argument'],
        SequenceExpression: ['expressions'],
        SwitchCase: ['test', 'consequent'],
        SwitchStatement: ['discriminant', 'cases'],
        ThisExpression: [],
        ThrowStatement: ['argument'],
        TryStatement: ['block', 'handlers', 'guardedHandlers', 'finalizer'],
        UnaryExpression: ['operator', 'argument'],
        UpdateExpression: ['operator', 'argument', 'prefix'],
        VariableDeclaration: ['kind', 'declarations'],
        VariableDeclarator: ['id', 'init'],
        WhileStatement: ['test', 'body'],
        WithStatement: ['object', 'body']
      };
      terminals = {
        keyword: function(keyword) {
          return region('keyword', function() {
            return str.push(keyword);
          });
        },
        literal: function(raw) {
          return str.push(raw);
        },
        newline: (function() {
          var first;

          first = true;
          return function() {
            if (first) {
              return first = false;
            } else {
              return str.push(options.format.html ? '<br />' : '\n');
            }
          };
        })(),
        operator: function(operator) {
          return region('operator', function() {
            return str.push(operator);
          });
        },
        punctuation: function(symbol) {
          return region('punctuation', function() {
            return str.push(symbol);
          });
        },
        semicolon: function() {
          return region('punctuation', function() {
            if (options.format.semicolons) {
              return str.push(';');
            }
          });
        },
        space: function() {
          return str.push(options.format.html ? '&nbsp;' : ' ');
        }
      };
      generators = {
        ArrayExpression: function(elements) {
          terminals.punctuation('[');
          between(elements, codegen, function() {
            terminals.punctuation(',');
            return terminals.space();
          });
          return terminals.punctuation(']');
        },
        AssignmentExpression: function(left, operator, right) {
          codegen(left);
          terminals.space();
          terminals.operator(operator);
          terminals.space();
          return codegen(right);
        },
        BinaryExpression: function(left, operator, right) {
          terminals.punctuation('((');
          codegen(left);
          terminals.punctuation(')');
          terminals.space();
          terminals.operator(operator);
          terminals.space();
          terminals.punctuation('(');
          codegen(right);
          return terminals.punctuation('))');
        },
        /*
        			Generate the code for a block statement
        			opts.inline suppresses newlines before and after
        */

        BlockStatement: function(body, opts) {
          var el, _i, _len;

          if (!opts.inline) {
            indent(-1, true);
          }
          terminals.punctuation('{');
          for (_i = 0, _len = body.length; _i < _len; _i++) {
            el = body[_i];
            codegen(el);
          }
          indent(-1, true);
          return terminals.punctuation('}');
        },
        BreakStatement: function(label, opts) {
          if (label != null) {
            throw 'BreakStatement#label not supported.';
          }
          if (!opts.inline) {
            indent();
          }
          terminals.keyword('break');
          return terminals.semicolon();
        },
        CallExpression: function(callee, _arguments) {
          if (callee.type === 'FunctionExpression') {
            terminals.punctuation('(');
          }
          codegen(callee);
          if (callee.type === 'FunctionExpression') {
            terminals.punctuation(')');
          }
          terminals.punctuation('(');
          between(_arguments, codegen, function() {
            terminals.punctuation(',');
            return terminals.space();
          });
          return terminals.punctuation(')');
        },
        CatchClause: function(param, guard, body) {
          if (guard != null) {
            throw 'CatchClause#guard not supported.';
          }
          terminals.space();
          terminals.keyword('catch');
          terminals.space();
          terminals.punctuation('(');
          codegen(param);
          terminals.punctuation(')');
          terminals.space();
          return codegen(body, {
            inline: true
          });
        },
        ConditionalExpression: function(test, consequent, alternate) {
          codegen(test);
          terminals.space();
          terminals.operator('?');
          terminals.space();
          codegen(consequent);
          terminals.space();
          terminals.operator(':');
          terminals.space();
          return codegen(alternate);
        },
        ContinueStatement: function(label, opts) {
          if (label != null) {
            throw 'ContinueStatement#label not supported.';
          }
          if (!opts.inline) {
            indent();
          }
          terminals.keyword('continue');
          return terminals.semicolon();
        },
        DoWhileStatement: function(body, test) {
          indent();
          indentation++;
          terminals.keyword('do ');
          codegen(body, {
            inline: true
          });
          terminals.space();
          terminals.keyword('while');
          terminals.space();
          terminals.punctuation('(');
          codegen(test);
          return terminals.punctuation(')');
        },
        EmptyStatement: function(opts) {
          if (!opts.inline) {
            indent();
          }
          return terminals.semicolon();
        },
        ExpressionStatement: function(expression, opts) {
          if (!opts.inline) {
            indent();
          }
          codegen(expression);
          return terminals.semicolon();
        },
        ForInStatement: function(left, right, body, each) {
          indent();
          terminals.keyword('for');
          terminals.space();
          if (each) {
            terminals.keyword('each');
            terminals.space();
          }
          terminals.punctuation('(');
          indentation++;
          codegen(left, {
            init: true
          });
          terminals.space();
          terminals.keyword('in');
          terminals.space();
          codegen(right);
          terminals.punctuation(')');
          terminals.space();
          codegen(body, {
            inline: true
          });
          return indentation--;
        },
        ForOfStatement: function(left, right, body) {
          indent();
          terminals.keyword('for');
          terminals.space();
          terminals.punctuation('(');
          indentation++;
          codegen(left, {
            init: true
          });
          terminals.space();
          terminals.keyword('of');
          terminals.space();
          codegen(right);
          terminals.punctuation(')');
          terminals.space();
          codegen(body, {
            inline: true
          });
          return indentation--;
        },
        ForStatement: function(init, test, update, body) {
          indent();
          terminals.keyword('for');
          terminals.space();
          terminals.punctuation('(');
          indentation++;
          if (init) {
            codegen(init, {
              init: true
            });
          }
          terminals.punctuation(';');
          terminals.space();
          if (test) {
            codegen(test);
          }
          terminals.punctuation(';');
          terminals.space();
          if (update) {
            codegen(update);
          }
          terminals.punctuation(')');
          terminals.space();
          codegen(body, {
            inline: true
          });
          return indentation--;
        },
        FunctionDeclaration: function(id, params, defaults, rest, body) {
          if (defaults.length) {
            throw 'FunctionDeclaration#defaults not supported.';
          }
          indent();
          indentation++;
          terminals.keyword('function');
          terminals.space();
          codegen(id);
          terminals.space();
          terminals.punctuation('(');
          between(params, codegen, function() {
            terminals.punctuation(',');
            return terminals.space();
          });
          terminals.punctuation(')');
          terminals.space();
          codegen(body, {
            inline: true
          });
          return indentation--;
        },
        FunctionExpression: function(id, params, defaults, rest, body) {
          if (defaults.length) {
            throw 'FunctionExpression#defaults not supported.';
          }
          indentation++;
          terminals.keyword('function');
          terminals.space();
          if (id != null) {
            codegen(id, indent);
          }
          terminals.punctuation('(');
          between(params, codegen, function() {
            terminals.punctuation(',');
            return terminals.space();
          });
          terminals.punctuation(')');
          terminals.space();
          codegen(body, {
            inline: true
          });
          return indentation--;
        },
        Identifier: function(name) {
          return str.push(name);
        },
        IfStatement: function(test, consequent, alternate, opts) {
          if (!opts.inline) {
            indent();
            indentation++;
          }
          terminals.keyword('if');
          terminals.space();
          terminals.punctuation('(');
          codegen(test, indent);
          terminals.punctuation(')');
          terminals.space();
          codegen(consequent, {
            inline: true
          });
          if (alternate != null) {
            terminals.space();
            terminals.keyword('else');
            terminals.space();
            codegen(alternate, {
              inline: true
            });
          }
          if (!opts.inline) {
            return indentation--;
          }
        },
        LabeledStatement: function(label, body) {
          throw 'LabeledStatement not supported.';
        },
        Literal: function(raw) {
          return terminals.literal(raw);
        },
        LogicalExpression: function(left, operator, right) {
          terminals.punctuation('((');
          codegen(left);
          terminals.punctuation(')');
          terminals.space();
          terminals.operator(operator);
          terminals.space();
          terminals.punctuation('(');
          codegen(right);
          return terminals.punctuation('))');
        },
        MemberExpression: function(object, property, computed) {
          if (object.type === 'FunctionExpression') {
            terminals.punctuation('(');
          }
          codegen(object);
          if (object.type === 'FunctionExpression') {
            terminals.punctuation(')');
          }
          if (computed) {
            terminals.punctuation('[');
            codegen(property);
            return terminals.punctuation(']');
          } else {
            terminals.punctuation('.');
            return codegen(property);
          }
        },
        NewExpression: function(callee, _arguments) {
          terminals.keyword('new');
          terminals.space();
          codegen(callee);
          terminals.punctuation('(');
          between(_arguments, codegen, function() {
            terminals.punctuation(',');
            return terminals.space();
          });
          return terminals.punctuation(')');
        },
        ObjectExpression: function(properties) {
          terminals.punctuation('{');
          if (properties != null ? properties.length : void 0) {
            indentation++;
            between(properties, codegen, function() {
              return terminals.punctuation(',');
            });
            indentation--;
            indent();
          }
          return terminals.punctuation('}');
        },
        Program: function(body) {
          var el, _i, _len, _results;

          _results = [];
          for (_i = 0, _len = body.length; _i < _len; _i++) {
            el = body[_i];
            _results.push(codegen(el));
          }
          return _results;
        },
        Property: function(key, value) {
          indent();
          codegen(key);
          terminals.punctuation(':');
          terminals.space();
          return codegen(value);
        },
        ReturnStatement: function(argument, opts) {
          if (!opts.inline) {
            indent();
          }
          terminals.keyword('return');
          if (argument != null) {
            terminals.space();
            codegen(argument);
          }
          return terminals.semicolon();
        },
        SequenceExpression: function(expressions) {
          return between(expressions, codegen, function() {
            terminals.punctuation(',');
            return terminals.space();
          });
        },
        SwitchCase: function(test, consequent) {
          var cons, _i, _len, _results;

          indent(-1, true);
          if (test === null) {
            terminals.keyword('default');
          } else {
            terminals.keyword('case');
            terminals.space();
            codegen(test);
          }
          terminals.punctuation(':');
          _results = [];
          for (_i = 0, _len = consequent.length; _i < _len; _i++) {
            cons = consequent[_i];
            _results.push(codegen(cons));
          }
          return _results;
        },
        SwitchStatement: function(discriminant, cases) {
          var _case, _i, _len;

          indent();
          terminals.keyword('switch');
          terminals.space();
          terminals.punctuation('(');
          codegen(discriminant);
          terminals.punctuation(')');
          terminals.space();
          terminals.punctuation('{');
          indentation++;
          for (_i = 0, _len = cases.length; _i < _len; _i++) {
            _case = cases[_i];
            codegen(_case);
          }
          return indentation--;
        },
        ThisExpression: function() {
          return terminals.keyword('this');
        },
        ThrowStatement: function(argument, opts) {
          if (!opts.inline) {
            indent();
          }
          terminals.keyword('throw');
          terminals.space();
          codegen(argument);
          return terminals.semicolon();
        },
        TryStatement: function(block, handlers, guardedHandlers, finalizer) {
          var handler, _i, _len;

          if (guardedHandlers.length) {
            throw 'TryStatement#guardedHandlers not supported.';
          }
          indent();
          indentation++;
          terminals.keyword('try');
          terminals.space();
          codegen(block, {
            inline: true
          });
          for (_i = 0, _len = handlers.length; _i < _len; _i++) {
            handler = handlers[_i];
            codegen(handler);
          }
          if (finalizer) {
            codegen(finalizer);
          }
          return indentation--;
        },
        UnaryExpression: function(operator, argument) {
          terminals.punctuation('(');
          terminals.operator(operator);
          terminals.punctuation('(');
          codegen(argument);
          return terminals.punctuation('))');
        },
        UpdateExpression: function(operator, argument, prefix) {
          if (prefix) {
            terminals.operator(operator);
          }
          codegen(argument, indent);
          if (!prefix) {
            return terminals.operator(operator);
          }
        },
        VariableDeclaration: function(kind, declarations, opts) {
          if (!opts.init) {
            indent();
          }
          terminals.keyword(kind);
          terminals.space();
          between(declarations, codegen, function() {
            terminals.punctuation(',');
            return terminals.space();
          });
          if (!opts.init) {
            return terminals.semicolon();
          }
        },
        VariableDeclarator: function(id, init) {
          codegen(id);
          if (init != null) {
            terminals.space();
            terminals.operator('=');
            terminals.space();
            return codegen(init);
          }
        },
        WithStatement: function(object, body) {
          indent();
          indentation++;
          terminals.keyword('with');
          terminals.space();
          terminals.punctuation('(');
          codegen(object);
          terminals.punctuation(')');
          terminals.space();
          return codegen(body, {
            inline: true
          });
        },
        WhileStatement: function(test, body) {
          indent();
          indentation++;
          terminals.keyword('while');
          terminals.space();
          terminals.punctuation('(');
          codegen(test);
          terminals.punctuation(')');
          terminals.space();
          codegen(body, {
            inline: true
          });
          return indentation--;
        }
      };
      cssify = function(name) {
        return name.replace(/\W+/g, '-').replace(/([a-z\d])([A-Z])/g, '$1-$2').toLowerCase();
      };
      codegen = function(code, opts) {
        if (opts == null) {
          opts = {};
        }
        if ((generators[code.type] != null) && (syntax[code.type] != null)) {
          region(cssify(code.type), function() {
            var prop;

            return generators[code.type].apply(null, ((function() {
              var _i, _len, _ref, _results;

              _ref = syntax[code.type];
              _results = [];
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                prop = _ref[_i];
                _results.push(code[prop]);
              }
              return _results;
            })()).concat(opts));
          });
        } else {
          str.push('????');
          console.error("Unknown type " + code.type, code);
        }
      };
      codegen(tree);
      return str.join('');
    };
    return {
      generate: generate
    };
  });

}).call(this);
