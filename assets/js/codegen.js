// Generated by CoffeeScript 1.6.2
(function() {
  (function(root, factory) {
    if (typeof exports === 'object') {
      return module.exports = factory();
    } else if (typeof define === 'function' && define.amd) {
      return define(factory);
    } else {
      return root.Codegen = factory();
    }
  })(this, function() {
    'use strict';
    var generate;

    generate = function(tree, options) {
      var between, codegen, err, generators, indent, indentation, newline, region, semicolon, str, syntax;

      options = $.extend(true, {
        format: {
          indent: {
            style: '    ',
            base: 0
          },
          semicolons: true
        }
      }, options);
      console.dir(options);
      str = [];
      indentation = options.format.indent.base;
      between = function(els, fn, bw) {
        var el, run, _i, _len, _results;

        run = false;
        _results = [];
        for (_i = 0, _len = els.length; _i < _len; _i++) {
          el = els[_i];
          if (run) {
            if (typeof bw === 'function') {
              bw();
            } else if (typeof bw === 'string') {
              str.push(bw);
            }
          }
          fn(el);
          _results.push(run = true);
        }
        return _results;
      };
      newline = function() {
        return str.push('<br />');
      };
      /*
      		Indent a new line to the correct level
      		delta increases or decreases indentation level
      		temp does not update indent level
      */

      indent = function(delta, temp) {
        var i;

        newline();
        str.push(((function() {
          var _i, _ref, _results;

          _results = [];
          for (i = _i = 0, _ref = indentation + (+delta || 0); 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            _results.push(options.format.indent.style);
          }
          return _results;
        })()).join(''));
        if (!temp) {
          return indentation += +delta || 0;
        }
      };
      semicolon = function() {
        if (options.format.semicolons) {
          return str.push(';');
        }
      };
      region = function(type, cont) {
        str.push("<span class=" + type + ">");
        cont();
        return str.push('</span>');
      };
      syntax = {
        ArrayExpression: ['elements'],
        AssignmentExpression: ['left', 'operator', 'right'],
        BinaryExpression: ['left', 'operator', 'right'],
        BlockStatement: ['body'],
        BreakStatement: ['label'],
        CallExpression: ['callee', 'arguments'],
        CatchClause: ['param', 'guard', 'body'],
        ConditionalExpression: ['test', 'consequent', 'alternate'],
        ContinueStatement: ['label'],
        DebuggerStatement: [],
        DoWhileStatement: ['body', 'test'],
        EmptyStatement: [],
        ExpressionStatement: ['expression'],
        ForInStatement: ['left', 'right', 'body', 'each'],
        ForOfStatement: ['left', 'right', 'body'],
        ForStatement: ['init', 'test', 'update', 'body'],
        FunctionDeclaration: ['id', 'params', 'defaults', 'rest', 'body'],
        FunctionExpression: ['id', 'params', 'defaults', 'rest', 'body'],
        Identifier: ['name'],
        IfStatement: ['test', 'consequent', 'alternate'],
        LabeledStatement: ['label', 'body'],
        Literal: ['raw'],
        LogicalExpression: ['left', 'operator', 'right'],
        MemberExpression: ['object', 'property', 'computed'],
        NewExpression: ['callee', 'arguments'],
        ObjectExpression: ['properties'],
        Pattern: [],
        Program: ['body'],
        Property: ['key', 'value'],
        ReturnStatement: ['argument'],
        SequenceExpression: ['expressions'],
        SwitchCase: ['test', 'consequent'],
        SwitchStatement: ['discriminant', 'cases'],
        ThisExpression: [],
        ThrowStatement: ['argument'],
        TryStatement: ['block', 'handlers', 'guardedHandlers', 'finalizer'],
        UnaryExpression: ['operator', 'argument'],
        UpdateExpression: ['operator', 'argument', 'prefix'],
        VariableDeclaration: ['kind', 'declarations'],
        VariableDeclarator: ['id', 'init'],
        WhileStatement: ['test', 'body'],
        WithStatement: ['object', 'body']
      };
      generators = {
        ArrayExpression: function(elements) {
          str.push('[');
          between(elements, codegen, ', ');
          return str.push(']');
        },
        AssignmentExpression: function(left, operator, right) {
          codegen(left);
          str.push(' ');
          str.push(operator);
          str.push(' ');
          return codegen(right);
        },
        BinaryExpression: function(left, operator, right) {
          str.push('((');
          codegen(left);
          str.push(') ');
          str.push(operator);
          str.push(' (');
          codegen(right);
          return str.push('))');
        },
        /*
        			Generate the code for a block statement
        			opts.inline suppresses newlines before and after
        */

        BlockStatement: function(body, opts) {
          var el, _i, _len;

          if (!opts.inline) {
            indent(-1, true);
          }
          str.push('{');
          for (_i = 0, _len = body.length; _i < _len; _i++) {
            el = body[_i];
            codegen(el);
          }
          indent(-1, true);
          return str.push('}');
        },
        BreakStatement: function(label, opts) {
          if (label != null) {
            throw 'BreakStatement#label not supported.';
          }
          if (!opts.inline) {
            indent();
          }
          return str.push('break;');
        },
        CallExpression: function(callee, _arguments) {
          if (callee.type === 'FunctionExpression') {
            str.push('(');
          }
          codegen(callee);
          if (callee.type === 'FunctionExpression') {
            str.push(')');
          }
          str.push('(');
          between(_arguments, codegen, ', ');
          return str.push(')');
        },
        CatchClause: function(param, guard, body) {
          if (guard != null) {
            throw 'CatchClause#guard not supported.';
          }
          str.push(' catch (');
          codegen(param);
          str.push(') ');
          return codegen(body, {
            inline: true
          });
        },
        ConditionalExpression: function(test, consequent, alternate) {
          codegen(test);
          str.push(' ? ');
          codegen(consequent);
          str.push(' : ');
          return codegen(alternate);
        },
        ContinueStatement: function(label, opts) {
          if (label != null) {
            throw 'ContinueStatement#label not supported.';
          }
          if (!opts.inline) {
            indent();
          }
          return str.push('continue;');
        },
        DoWhileStatement: function(body, test) {
          indent();
          indentation++;
          str.push('do ');
          codegen(body, {
            inline: true
          });
          str.push(' while (');
          codegen(test);
          return str.push(')');
        },
        EmptyStatement: function(opts) {
          if (!opts.inline) {
            indent();
          }
          return semicolon();
        },
        ExpressionStatement: function(expression, opts) {
          if (!opts.inline) {
            indent();
          }
          codegen(expression);
          return semicolon();
        },
        ForInStatement: function(left, right, body, each) {
          indent();
          str.push(each ? 'for each (' : 'for (');
          indentation++;
          codegen(left, {
            init: true
          });
          str.push(' in ');
          codegen(right);
          str.push(') ');
          codegen(body, {
            inline: true
          });
          return indentation--;
        },
        ForOfStatement: function(left, right, body) {
          indent();
          str.push('for (');
          indentation++;
          codegen(left, {
            init: true
          });
          str.push(' of ');
          codegen(right);
          str.push(') ');
          codegen(body, {
            inline: true
          });
          return indentation--;
        },
        ForStatement: function(init, test, update, body) {
          indent();
          str.push('for (');
          indentation++;
          if (init) {
            codegen(init, {
              init: true
            });
          }
          str.push('; ');
          if (test) {
            codegen(test);
          }
          str.push('; ');
          if (update) {
            codegen(update);
          }
          str.push(') ');
          codegen(body, {
            inline: true
          });
          return indentation--;
        },
        FunctionDeclaration: function(id, params, defaults, rest, body) {
          return region('function-declaration', function() {
            if (defaults.length) {
              throw 'FunctionDeclaration#defaults not supported.';
            }
            indent();
            indentation++;
            str.push('function ');
            codegen(id);
            str.push('(');
            between(params, codegen, ', ');
            str.push(') ');
            codegen(body, {
              inline: true
            });
            return indentation--;
          });
        },
        FunctionExpression: function(id, params, defaults, rest, body) {
          if (defaults.length) {
            throw 'FunctionExpression#defaults not supported.';
          }
          indentation++;
          str.push('function ');
          if (id != null) {
            codegen(id, indent);
          }
          str.push('(');
          between(params, codegen, ', ');
          str.push(') ');
          codegen(body, {
            inline: true
          });
          return indentation--;
        },
        Identifier: function(name) {
          return region('identifier', function() {
            return str.push(name);
          });
        },
        IfStatement: function(test, consequent, alternate, opts) {
          if (!opts.inline) {
            indent();
            indentation++;
          }
          str.push('if (');
          codegen(test, indent);
          str.push(') ');
          codegen(consequent, {
            inline: true
          });
          if (alternate != null) {
            str.push(' else ');
            codegen(alternate, {
              inline: true
            });
          }
          if (!opts.inline) {
            return indentation--;
          }
        },
        LabeledStatement: function(label, body) {
          throw 'LabeledStatement not supported.';
        },
        Literal: function(raw) {
          return str.push(raw);
        },
        LogicalExpression: function(left, operator, right) {
          str.push('((');
          codegen(left);
          str.push(') ');
          str.push(operator);
          str.push(' (');
          codegen(right);
          return str.push('))');
        },
        MemberExpression: function(object, property, computed) {
          if (object.type === 'FunctionExpression') {
            str.push('(');
          }
          codegen(object);
          if (object.type === 'FunctionExpression') {
            str.push(')');
          }
          if (computed) {
            str.push('[');
            codegen(property);
            return str.push(']');
          } else {
            str.push('.');
            return codegen(property);
          }
        },
        NewExpression: function(callee, _arguments) {
          str.push('new ');
          codegen(callee);
          str.push('(');
          between(_arguments, codegen, ', ');
          return str.push(')');
        },
        ObjectExpression: function(properties) {
          str.push('{');
          if (properties != null ? properties.length : void 0) {
            indentation++;
            between(properties, codegen, ',');
            indentation--;
            indent();
          }
          return str.push('}');
        },
        Program: function(body) {
          var el, _i, _len, _results;

          _results = [];
          for (_i = 0, _len = body.length; _i < _len; _i++) {
            el = body[_i];
            _results.push(codegen(el));
          }
          return _results;
        },
        Property: function(key, value) {
          indent();
          codegen(key);
          str.push(': ');
          return codegen(value);
        },
        ReturnStatement: function(argument, opts) {
          if (!opts.inline) {
            indent();
          }
          str.push('return');
          if (argument != null) {
            str.push(' ');
            codegen(argument);
          }
          return semicolon();
        },
        SequenceExpression: function(expressions) {
          return between(expressions, codegen, ', ');
        },
        SwitchCase: function(test, consequent) {
          var cons, _i, _len, _results;

          indent(-1, true);
          if (test === null) {
            str.push('default');
          } else {
            str.push('case ');
            codegen(test);
          }
          str.push(':');
          _results = [];
          for (_i = 0, _len = consequent.length; _i < _len; _i++) {
            cons = consequent[_i];
            _results.push(codegen(cons));
          }
          return _results;
        },
        SwitchStatement: function(discriminant, cases) {
          var _case, _i, _len;

          indent();
          str.push('switch (');
          codegen(discriminant);
          str.push(') {');
          indentation++;
          for (_i = 0, _len = cases.length; _i < _len; _i++) {
            _case = cases[_i];
            codegen(_case);
          }
          return indentation--;
        },
        ThisExpression: function() {
          return str.push('this');
        },
        ThrowStatement: function(argument, opts) {
          if (!opts.inline) {
            indent();
          }
          str.push('throw ');
          codegen(argument);
          return semicolon();
        },
        TryStatement: function(block, handlers, guardedHandlers, finalizer) {
          var handler, _i, _len;

          if (guardedHandlers.length) {
            throw 'TryStatement#guardedHandlers not supported.';
          }
          indent();
          indentation++;
          str.push('try ');
          codegen(block, {
            inline: true
          });
          for (_i = 0, _len = handlers.length; _i < _len; _i++) {
            handler = handlers[_i];
            codegen(handler);
          }
          if (finalizer) {
            codegen(finalizer);
          }
          return indentation--;
        },
        UnaryExpression: function(operator, argument) {
          str.push('(');
          str.push(operator);
          str.push('(');
          codegen(argument);
          return str.push('))');
        },
        UpdateExpression: function(operator, argument, prefix) {
          if (prefix) {
            str.push(operator);
          }
          codegen(argument, indent);
          if (!prefix) {
            return str.push(operator);
          }
        },
        VariableDeclaration: function(kind, declarations, opts) {
          return region('variable-declaration', function() {
            if (!opts.init) {
              indent();
            }
            str.push(kind);
            str.push(' ');
            between(declarations, codegen, ', ');
            if (!opts.init) {
              return semicolon();
            }
          });
        },
        VariableDeclarator: function(id, init) {
          codegen(id);
          if (init != null) {
            str.push(' = ');
            return codegen(init);
          }
        },
        WithStatement: function(object, body) {
          indent();
          indentation++;
          str.push('with (');
          codegen(object);
          str.push(') ');
          return codegen(body, {
            inline: true
          });
        },
        WhileStatement: function(test, body) {
          indent();
          indentation++;
          str.push('while (');
          codegen(test);
          str.push(') ');
          codegen(body, {
            inline: true
          });
          return indentation--;
        }
      };
      codegen = function(code, opts) {
        var prop;

        if (opts == null) {
          opts = {};
        }
        if ((generators[code.type] != null) && (syntax[code.type] != null)) {
          generators[code.type].apply(null, ((function() {
            var _i, _len, _ref, _results;

            _ref = syntax[code.type];
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              prop = _ref[_i];
              _results.push(code[prop]);
            }
            return _results;
          })()).concat(opts));
        } else {
          str.push('????');
          console.error("Unknown type " + code.type, code);
        }
      };
      try {
        codegen(tree);
      } catch (_error) {
        err = _error;
        console.error(err);
        return '';
      }
      console.log(str);
      return str.slice(1).join('');
    };
    return {
      generate: generate
    };
  });

}).call(this);
